{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#sweetspot-a-triangle-ray-interesction-project","title":"Sweetspot - a triangle-ray interesction project","text":"<p>By Audun Skau Hansen (audunsh4@gmail.com) 2022</p>"},{"location":"#why-triangles-a-bit-of-context","title":"Why triangles? A bit of context","text":"<p>Triangles in 3D spaces is one of the fundamental building-blocks of modern 3D graphics, and is thus the focus for quite a lot of research of efficient algorithms to draw, quantify/measure, process and transform these objects. Furthermore, modern GPUs are specifically designed to project many of these objects onto the 2D computer monitor efficiently, which means that if you can formulate any problem in a fashion similar to how 3D graphics is done (i.e. massively parallell, very little communication between the cores, GPU-friendly code), there is a great deal of perfomance payoff to gain. Core algorithms like matrix-matrix products, fourier transforms and in recent years stochastic gradient descent (for use in AI/ML) has for this reason been adapted to GPU-architectures, and it is reasonable to expect much more developement on the field.</p> <p>The intersection of rays and triangles is useful for many purposes, with probably the most apparent being the projection of a triangle onto a 2D pixelated computer monitor. Given the vast amounts of triangles present in modern 3D graphics, it is clear that any such algorithm should be as optimized as possible. </p> <p>Beyond simply drawing the triangles, the same algorithm can be used in ray-tracing techniques, in order to simulate the scattering and reflection of light in 3D environments. Furthermore, the same kinds of algorithms may be used in user-interaction, to allow for point-and-click functionality in 3D environments. </p> <p>In the following, we shall give an overview of the algebraic problem and implement (1) a classic algebraic solver and (2) a more standard M\u00f6ller-Trumbore algorithm [1]. We also discuss a more recent contribution to the field [2]. Finally, we conclude with some general comments and future prospects and ideas. </p> <p>This project was given as a challenge for an application to a position for an R&amp;D Engineering position in December 2022.</p> <p></p> Figure above: The algorithms has been validated in several steps, from visual inspection to automated comparisons. <p></p>"},{"location":"#notation-and-conventions","title":"Notation and conventions","text":"<p>In the following, we will use boldfont letters \\(\\mathbf{A}, \\mathbf{X},\\mathbf{y}\\) etc.,  to represent cartesian vectors, and uppercase letters such as \\(R, T,...\\) to represent subspaces within \\(\\mathbb{R}^n\\). Lowercase letters like \\(a, x, ...\\) represent scalars unless stated otherwise.</p>"},{"location":"#problem-overview","title":"Problem overview","text":"<p>A ray \\(R\\) in three-dimensional space ( \\(\\mathbb{R}^3\\) ) can be defined as the set of all points \\(\\mathbf{P}\\)  on a line segment extending to infinity from the cartesian origin vector \\(\\mathbf{O}\\) in the normalized direction \\(\\mathbf{D}\\):</p> <p>$$ \\mathbf{P} = \\mathbf{O} + a \\mathbf{D},  \\tag{1} $$ where \\(a\\) is a real, positive number.</p> <p>In the same space, we consider a triangle \\(T\\) defined by the set of three cartesian vectors \\(\\{ \\mathbf{x}_1,\\mathbf{x}_2,\\mathbf{x}_3\\}\\). Any point on the plane spanned by the triangle, but contained within the region delimited by the lines \\(\\{ \\mathbf{x}_i,\\mathbf{x}_j\\}_{i\\neq j}\\)   is an element of \\(T\\).</p> <p>The problem we are going to solve is to find the intersection  $$ R \\cap T, \\tag{2} $$ where the ray intersects the triangle.</p> <p>Intuitively, it makes sense to consider this a two-step procedure, consisting of first determining where (and if) the ray intersects the plane spanned by the triangle, whereby we determine whether the intersection point is within the triangle.</p>"},{"location":"#sources","title":"Sources","text":"<p>[1] M\u00f6ller, T., &amp; Trumbore, B. (2005). Fast, minimum storage ray/triangle intersection. In\u00a0ACM SIGGRAPH 2005 Courses\u00a0(pp. 7-es).</p> <p>[2] Pichler, T. A., Ferko, A., Ferko, M., K\u00e1n, P., &amp; Kaufmann, H. (2022). Precomputed fast rejection ray-triangle intersection.\u00a0Graphics and Visual Computing, 200047.</p>"},{"location":"Sweetspot-reference/","title":"Sweetspot module","text":""},{"location":"Sweetspot-reference/#sweetspot.core.ray","title":"<code>ray</code>","text":"<p>A ray \\(R\\) in three-dimensional space ( \\(\\mathbb{R}^3\\) ).</p> <p>Author: Audun Skau Hansen (audunsh4@gmail.com), 2022 </p> <p>Defined as the set of all points \\(\\mathbf{P}\\)  on a line  segment extending to infinity from the cartesian origin  vector \\(\\mathbf{O}\\) in the normalized direction \\(\\mathbf{D}\\): $$ \\mathbf{P} = \\mathbf{O} + a \\mathbf{D},          ag{1} $$ where \\(a\\) is a real, positive number.</p> Arguments Description origin a 3-component numpy-array defining the rays origin direction a 3-component numpy array defining the direction of the ray   (will be normalized automatically) Source code in <code>sweetspot/core.py</code> <pre><code>class ray():\n    \"\"\"\n    A *ray* $R$ in three-dimensional space ( $\\mathbb{R}^3$ ).\n\n    Author: Audun Skau Hansen (audunsh4@gmail.com), 2022 \n\n    Defined as the set of all points $\\mathbf{P}$  on a line \n    segment extending to infinity from the cartesian origin \n    vector $\\mathbf{O}$ in the normalized *direction* $\\mathbf{D}$:\n    $$ \\mathbf{P} = \\mathbf{O} + a \\mathbf{D},  \\tag{1} $$\n    where $a$ is a real, positive number.\n\n    | Arguments      | Description |\n    | ----------- | ----------- |\n    | origin     | a 3-component numpy-array defining the rays origin   |\n    | direction   | a 3-component numpy array defining the direction of the ray   (will be normalized automatically)  |\n\n    \"\"\"\n    def __init__(self, origin:np.ndarray, direction:np.ndarray)-&gt;None:\n        self.origin = origin\n\n        # note that direction is automatically normalized\n        self.direction = direction/np.dot(direction, direction)**.5\n\n    def get_point_at(self, a: float)-&gt;np.ndarray:\n        \"\"\"\n        Returns the point:\n\n        $$\\mathbf{P}(a) = \\mathbf{O} + a \\mathbf{D}$$\n\n        \"\"\"\n        assert(a&gt;=0), \"Requested point is outside ray\"\n        return self.origin + self.direction*a\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.ray.get_point_at","title":"<code>get_point_at(a)</code>","text":"<p>Returns the point:</p> \\[\\mathbf{P}(a) = \\mathbf{O} + a \\mathbf{D}\\] Source code in <code>sweetspot/core.py</code> <pre><code>def get_point_at(self, a: float)-&gt;np.ndarray:\n    \"\"\"\n    Returns the point:\n\n    $$\\mathbf{P}(a) = \\mathbf{O} + a \\mathbf{D}$$\n\n    \"\"\"\n    assert(a&gt;=0), \"Requested point is outside ray\"\n    return self.origin + self.direction*a\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle","title":"<code>triangle</code>","text":"<p>A triangle in three-dimensional space ( \\(\\mathbb{R}^3\\) ).</p> <p>Author: Audun Skau Hansen (audunsh4@gmail.com), 2022</p> Arguments Description x1,x2,x3 3-component numpy-arrays defining the vertices of the triangle Source code in <code>sweetspot/core.py</code> <pre><code>class triangle():\n    \"\"\"\n    A triangle in three-dimensional space ( $\\mathbb{R}^3$ ).\n\n    Author: Audun Skau Hansen (audunsh4@gmail.com), 2022\n\n    | Arguments      | Description |\n    | ----------- | ----------- |\n    | x1,x2,x3     |  3-component numpy-arrays defining the vertices of the triangle   |\n\n    \"\"\"\n    def __init__(self, x1:np.ndarray, x2:np.ndarray, x3:np.ndarray):\n        self.X = [x1,x2,x3]\n\n    def compute_norm(self):\n        \"\"\"\n        computes the norm (normalized) of the triangle\n        \"\"\"\n        n = np.cross(self.X[0]- self.X[1], self.X[0]-self.X[2])\n        return n/np.dot(n,n)**.5\n\n    def compute_distance_to_origin(self)-&gt;float:\n        \"\"\"\n        Compute distance from (0,0,0) to the plane spanned by the triangle.\n        \"\"\"\n        return self.compute_norm().dot(self.X[0])\n\n    def compute_edge_vector(self,i,j)-&gt;np.ndarray:\n        \"\"\"\n        Computes the edge-vector between vertex $i$ and $j$.\n        \"\"\"\n        return self.X[i] - self.X[j]\n\n    def compute_area(self, points = None)-&gt;np.ndarray:\n        \"\"\"\n        Computes the area of the triangle.\n        \"\"\"\n        if points is None:\n            points = self.X\n\n        A_ = np.cross(points[1]-points[0], points[2]-points[0])\n        return .5*np.dot(A_, A_)**.5\n\n\n    def compute_barycentric_coordinates_area(self, point)-&gt;np.ndarray:\n        \"\"\"\n        Compute the barycentric coordinates of point,\n        assuming it is on the plane spanne by triangle\n        using the area method\n        [https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Barycentric_coordinates_on_triangles]\n        \"\"\"\n        x1,x2,x3 = self.X\n\n        W  = self.compute_area()\n        u1 = self.compute_area(points = [x1,x2,point])/W\n        u2 = self.compute_area(points = [x2,x3,point])/W\n        u3 = 1-u1-u2\n        #w3 = self.compute_area(points = [x1,x2,point])\n        return np.array([u1,u2,u3])\n\n    def compute_barycentric_coordinates(self, point)-&gt;np.ndarray:\n        \"\"\"\n        Compute the barycentric coordinates of point,\n        assuming it is on the plane spanned by triangle\n        using Cramer's rule \n        [http://lavalle.pl/vr/node206.html]\n        \"\"\"\n        x1,x2,x3 = self.X\n        e1,e2 = x2-x1, x3-x1\n        w = point-x1\n\n        # compute matrix elements\n        d00 = e1.dot(e1)\n        d01 = e1.dot(e2)\n        d02 = e1.dot(w)\n        d11 = e2.dot(e2)\n        d12 = e2.dot(w)\n\n        det = 1/(d00*d11 - d01*d01)\n\n        u2 = det*(d00*d12 - d01*d02)\n        u1 = det*(d11*d02 - d01*d12)\n        u0 = 1-u2-u1\n        return np.array([u0,u1,u2])\n\n\n\n    def get_corner(self, i)-&gt;np.ndarray:\n        \"\"\"\n        Returns the corner $i$.\n        \"\"\"\n        return self.X[i]\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.compute_area","title":"<code>compute_area(points=None)</code>","text":"<p>Computes the area of the triangle.</p> Source code in <code>sweetspot/core.py</code> <pre><code>def compute_area(self, points = None)-&gt;np.ndarray:\n    \"\"\"\n    Computes the area of the triangle.\n    \"\"\"\n    if points is None:\n        points = self.X\n\n    A_ = np.cross(points[1]-points[0], points[2]-points[0])\n    return .5*np.dot(A_, A_)**.5\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.compute_barycentric_coordinates","title":"<code>compute_barycentric_coordinates(point)</code>","text":"<p>Compute the barycentric coordinates of point, assuming it is on the plane spanned by triangle using Cramer's rule  [http://lavalle.pl/vr/node206.html]</p> Source code in <code>sweetspot/core.py</code> <pre><code>def compute_barycentric_coordinates(self, point)-&gt;np.ndarray:\n    \"\"\"\n    Compute the barycentric coordinates of point,\n    assuming it is on the plane spanned by triangle\n    using Cramer's rule \n    [http://lavalle.pl/vr/node206.html]\n    \"\"\"\n    x1,x2,x3 = self.X\n    e1,e2 = x2-x1, x3-x1\n    w = point-x1\n\n    # compute matrix elements\n    d00 = e1.dot(e1)\n    d01 = e1.dot(e2)\n    d02 = e1.dot(w)\n    d11 = e2.dot(e2)\n    d12 = e2.dot(w)\n\n    det = 1/(d00*d11 - d01*d01)\n\n    u2 = det*(d00*d12 - d01*d02)\n    u1 = det*(d11*d02 - d01*d12)\n    u0 = 1-u2-u1\n    return np.array([u0,u1,u2])\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.compute_barycentric_coordinates_area","title":"<code>compute_barycentric_coordinates_area(point)</code>","text":"<p>Compute the barycentric coordinates of point, assuming it is on the plane spanne by triangle using the area method [https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Barycentric_coordinates_on_triangles]</p> Source code in <code>sweetspot/core.py</code> <pre><code>def compute_barycentric_coordinates_area(self, point)-&gt;np.ndarray:\n    \"\"\"\n    Compute the barycentric coordinates of point,\n    assuming it is on the plane spanne by triangle\n    using the area method\n    [https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Barycentric_coordinates_on_triangles]\n    \"\"\"\n    x1,x2,x3 = self.X\n\n    W  = self.compute_area()\n    u1 = self.compute_area(points = [x1,x2,point])/W\n    u2 = self.compute_area(points = [x2,x3,point])/W\n    u3 = 1-u1-u2\n    #w3 = self.compute_area(points = [x1,x2,point])\n    return np.array([u1,u2,u3])\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.compute_distance_to_origin","title":"<code>compute_distance_to_origin()</code>","text":"<p>Compute distance from (0,0,0) to the plane spanned by the triangle.</p> Source code in <code>sweetspot/core.py</code> <pre><code>def compute_distance_to_origin(self)-&gt;float:\n    \"\"\"\n    Compute distance from (0,0,0) to the plane spanned by the triangle.\n    \"\"\"\n    return self.compute_norm().dot(self.X[0])\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.compute_edge_vector","title":"<code>compute_edge_vector(i, j)</code>","text":"<p>Computes the edge-vector between vertex \\(i\\) and \\(j\\).</p> Source code in <code>sweetspot/core.py</code> <pre><code>def compute_edge_vector(self,i,j)-&gt;np.ndarray:\n    \"\"\"\n    Computes the edge-vector between vertex $i$ and $j$.\n    \"\"\"\n    return self.X[i] - self.X[j]\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.compute_norm","title":"<code>compute_norm()</code>","text":"<p>computes the norm (normalized) of the triangle</p> Source code in <code>sweetspot/core.py</code> <pre><code>def compute_norm(self):\n    \"\"\"\n    computes the norm (normalized) of the triangle\n    \"\"\"\n    n = np.cross(self.X[0]- self.X[1], self.X[0]-self.X[2])\n    return n/np.dot(n,n)**.5\n</code></pre>"},{"location":"Sweetspot-reference/#sweetspot.core.triangle.get_corner","title":"<code>get_corner(i)</code>","text":"<p>Returns the corner \\(i\\).</p> Source code in <code>sweetspot/core.py</code> <pre><code>def get_corner(self, i)-&gt;np.ndarray:\n    \"\"\"\n    Returns the corner $i$.\n    \"\"\"\n    return self.X[i]\n</code></pre>"},{"location":"Task/","title":"Task","text":"<p>Create a C++ library, with a function (and necessary types) for ray tracing triangles.</p> <p>The function should  - Take in a ray (https://en.wikipedia.org/wiki/Line_(geometry)#Ray) and a triangle as arguments.  - Return something that the consumer can use to determine:    - If the triangle was hit.    - What is the distance from the origin of the ray to the intersection point.    - The intersection point it self.</p> <p>Assume that this library is a core part of a software product, may need to be modified in the future, and will be used by many different consumers. Please provide some code that both tests the library and shows how to use the library.</p>"},{"location":"Task/#general-notes","title":"General Notes","text":"<ul> <li>Don't hesitate asking follow-up questions.</li> </ul>"},{"location":"Triangle%20intersection%20challenge/","title":"Triangle intersection challenge","text":"<p>Triangle intersection challenge.md</p>"},{"location":"al-reference/","title":"Sweetspot - Algebraic solver","text":""},{"location":"al-reference/#sweetspot.algebraic_solver.algebraic_ray_triangle_intersection","title":"<code>algebraic_ray_triangle_intersection(Ray, Triangle)</code>","text":"<p>The algebraic ray-triangle intersection algorithm </p> <p>Author: Audun Skau Hansen (audunsh4@gmail.com) 2022</p>"},{"location":"al-reference/#sweetspot.algebraic_solver.algebraic_ray_triangle_intersection--keyword-arguments","title":"Keyword arguments:","text":"Arguments Description Ray An instance of the sweetspot.ray class Triangle An instance of the sweetspot.triangle class"},{"location":"al-reference/#sweetspot.algebraic_solver.algebraic_ray_triangle_intersection--returns","title":"Returns","text":"<p>A tuple containing 'hit' (a boolean indicator of whether the ray intersected or not), a float value 'a_star' indicating the distance for which the ray intersected the triangle, and finally a vector 'p_star' indicating the cartesian vector of the intersection.</p> Source code in <code>sweetspot/algebraic_solver.py</code> <pre><code>def algebraic_ray_triangle_intersection(Ray: ray, Triangle: triangle)-&gt;(bool, float, np.array):\n    \"\"\"\n    The algebraic ray-triangle intersection algorithm \n\n    Author: Audun Skau Hansen (audunsh4@gmail.com) 2022\n\n    ## Keyword arguments:\n\n    | Arguments      | Description |\n    | ----------- | ----------- |\n    | Ray      |  An instance of the sweetspot.ray class    |\n    | Triangle   | An instance of the sweetspot.triangle class      |\n\n    ## Returns  \n\n    A tuple containing 'hit' (a boolean indicator of whether the ray intersected or not),\n    a float value 'a_star' indicating the distance for which the ray intersected the triangle,\n    and finally a vector 'p_star' indicating the cartesian vector of the intersection.\n\n    \"\"\"\n    hit = False\n    a_star = 0\n    p_star = np.zeros(3)\n\n\n    # Get origin and direction of ray\n    O = Ray.origin\n    D = Ray.direction\n\n    # compute the norm of the plane ( Eq.3 )\n    N = Triangle.compute_norm()\n\n    # assert that ray is not orthogonal to plane\n    if abs(np.dot(Ray.direction, N))&lt;1e-14:\n        # ray orthogonal to plane\n        return (hit, a_star, p_star)\n\n    # compute the distance of the plane \n    d = Triangle.compute_distance_to_origin()\n\n\n    # compute a_star (Eq. 5)\n    a_star = -((N.dot(O) - d)/N.dot(D))\n\n    if a_star&lt;0:\n        # triangle behind ray\n        return (hit, a_star, p_star)\n\n\n    # compute the intersection point (if any)\n    p_star = O + a_star*D\n\n\n    # compute barycentric coordinates\n    bcent = Triangle.compute_barycentric_coordinates(p_star)\n\n\n    if np.any(bcent&lt;0):\n        # point outside triangle\n        return (hit, a_star, p_star)\n\n\n\n\n\n    hit = True\n\n\n    return hit, a_star, p_star\n</code></pre>"},{"location":"algebraic_solver/","title":"The classic algebraic solution","text":""},{"location":"algebraic_solver/#intersecting-the-plane","title":"Intersecting the plane","text":"<p>The set of points \\(\\{\u00a0\\mathbf{x}_p \\}\\) on the  plane spanned by \\(T\\) are uniquely determined by the norm \\(\\mathbf{N}\\) of the triangle, given by the cross product</p> \\[\\mathbf{N} = \\frac{ (\\mathbf{x}_2 - \\mathbf{x}_1) \\times (\\mathbf{x}_3 - \\mathbf{x}_1)}{\\lVert (\\mathbf{x}_2 - \\mathbf{x}_1) \\times (\\mathbf{x}_3 - \\mathbf{x}_1) \\rVert}, \\tag{3}\\] <p>together with the distance \\(d\\) from \\((0,0,0)\\) to the center of the plane \\(\\mathbf{C}\\):</p> \\[ d = \\lVert  \\mathbf{C} \\rVert ,\\] <p>through the equation</p> \\[\\mathbf{N}\\cdot \\mathbf{x}_p - d =0.\\tag{4}\\] <p>Thus, for the point \\(x_* = P_*\\) where \\(R\\) intersects the plane, we find that inserting Eq.(1) in Eq.(3) yields </p> \\[\\mathbf{N}\\cdot(\\mathbf{O} + a_* \\mathbf{D}) - d =0.\\] <p>The above may be solved for \\(a_*\\) to find the relation</p> \\[a_* = -\\frac{\\mathbf{N}\\cdot \\mathbf{O}+d}{\\mathbf{N} \\cdot \\mathbf{D}}, \\tag{5}\\] <p>providing us with an explicit algebraic expression for the intersection point</p> \\[ \\mathbf{P}_* = \\mathbf{O} -\\Big{(} \\frac{\\mathbf{N}\\cdot \\mathbf{O}+d}{\\mathbf{N} \\cdot \\mathbf{D}}\\Big{)} \\mathbf{D}.  \\tag{6} \\] <p>We note that (i) the expression is singular when \\(\\mathbf{D}\\) is orthogonal to \\(\\mathbf{N}\\), indicating that the ray is parallel to the plane (they don't intersect) and (ii) the equation may yield a negative \\(a_*\\), indicating that the ray does not intersect the triangle (from our definition of \\(a\\) in Eq.(1).</p>"},{"location":"algebraic_solver/#boundary-check-on-triangle","title":"Boundary check on triangle","text":"<p>A standard way to determine whether or not the point \\(\\mathbf{P}_*\\) is within the triangle \\(T\\) is a so called point-in-polygon-test [1,2], which can be based on the fact that the cross-product between the vectors from the vertices of the triangle to the point \\(\\mathbf{P}_i=\\mathbf{x}_i - \\mathbf{P}_*\\)  and the vertex vectors \\(\\mathbf{X}_{ij}=\\mathbf{x}_j-\\mathbf{x}_i\\), where \\(i\\) and \\(j\\) are always chosen in the same cyclic (increasing) order should be aligned with the norm of the plane \\(\\mathbf{N}\\) whenever \\(\\mathbf{P}_*\\) is to the left of \\(\\mathbf{X}_ij\\) and oppositely aligned if not. </p> <p>Thus, the point \\(\\mathbf{P}_*\\) is inside the triangle \\(T\\) if</p> \\[\\mathbf{N} \\cdot (\\mathbf{X}_{ij} \\times \\mathbf{P}_i)&gt;0 \\: \\: \\forall \\: i \\in (1,2,3). \\] <p>Another approach is to do a coordinate transform into barycentric coordinates \\(\\{u_i\\}\\)  [3], where any negative coordinate will indicate the point being outside of the triangle. The barycentric unit vectors are simply the vertices of the triangle \\(\\{\\mathbf{x}_i\\}\\), so that the intersection point may now be expressed</p> \\[\\mathbf{P}_{*}=\\sum_i \\mathbf{x}_i u_i.\\] <p>In order to determine the coordinates, we may compute the fractional area of the of the triangles formed by \\(\\{\\mathbf{x}_i, \\mathbf{x}_j, \\mathbf{P}_*\\}_{i\\neq j}\\), such that</p> \\[u_1= \\frac{\\text{Area}(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{P}_*)}{\\text{Area}(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3)},\\] <p>and</p> \\[u_2= \\frac{\\text{Area}(\\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{P}_*)}{\\text{Area}(\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3)},\\] <p>and finally using the fact that \\(\\sum_i u_i = 1\\)  to obtain</p> \\[u_3 = 1 - u_1 - u_2. \\tag{7}\\] <p>For this project, we shall employ the latter method, since it also forms the basis for the more efficient M\u00f6ller-Trumbore algorithm we'll implement later on. </p>"},{"location":"algebraic_solver/#sources","title":"Sources","text":"<p>[1] https://en.wikipedia.org/wiki/Point_in_polygon</p> <p>[2] https://erich.realtimerendering.com/ptinpoly/</p> <p>[3] https://en.wikipedia.org/wiki/Barycentric_coordinate_system</p>"},{"location":"conclusion/","title":"Prospects and conclusion","text":"<p>Has there been any recent developement in the field? In a recent publication [1], Pichler et al. claims to demonstrate their algorithm named \"The Precomputed fast rejection ray-triangle intersection\" to promise speedups of up to 35% over the standard M\u00f6ller-Trumbore algorithm [2] by either (i) transforming the triangle into a unit triangle, simplifying certain aspects of the problem, or (ii) doing a similarity transform of the triangle onto a 2D surface, allowing for pruning of areas surrounding the triangle.</p> <p>Instead of replicating their review of the current state of the art here, I'd just like to point out that the paper offers an informative insight into the various venues which has been explored in order to reduce this computational bottleneck. However, the paper essentially indicates that under general conditions, the M\u00f6ller-Trumbore algorithm has yet to be defeated (altough there are algorithms able to compete and even superseed it under special conditions).</p> <p>The proposed method consists of the following steps: 1. Test for intersection between the ray and the bounding sphere, discard triangle if no intersection. 2. Calculate the ray-plane intersection point 3. Test whether the intersection point is inside the axis-aligned bounding-box (AABB) [3], discard if not. 4. Apply a 2D transform, and perform tests in 2D to determine if point is inside the triangle.</p>"},{"location":"conclusion/#speculations-and-ideas","title":"Speculations and ideas","text":"<p>As an afterthought - how does the human brain perform the same operation? Intuitively, we need only see the ray and triangle in front of us, and immediately recognize wheter or not they intersect. The effectiveness is essentially due to our ability to rapidly interpret complex stereoscopic information. It is however prone to misinterpretation and inaccuracies. Furthermore, it is clear that the visual representation we observe is not the same as the mathematical representation intetrpreted by the code (thus the need for projections in the first place).</p> <p>During this project, I've had some ideas however. Perhaps it could be useful to do a two step projection of the ray and the triangle; first onto the three planes spanned by the x-y, x-z and y-z unit vectors. Thereafter, for each of the three projections, the (2D triangle) and ray may now be projected as a section and point respectively on a circle around the rays origin. If the rays point (or angle) is within the section of the disc constituting the triangle in all three planes, I believe this would indicate that the ray intersects the triangle. (Unclear to me where exactly, though). This idea is gemetrically simple and on the face of it cheap (but I'm sure there is something I havent thought completely through still).</p> <p>A second idea would be to do something inspired by wavelets, having the triangles nested inside of eachother. I believe this procedure is similar to the recent Nanite-engine by Unreal.</p> <p>On a side-node, could ML-techniques (neural nets) be used? This is probably not such a good idea, since the core algorithms discussed here are significantly faster than what you achieve with moderately sized matrix-products, meaning that unless it were to be implemented on batches or a higher hiearchical level than the explicit triangles, it would probably perform slower than the standard algorithms used today. </p> <p>Finally, I'd like to just point out that there is room for further optimization of these algorithms. Actually, as you of course are aware, there is no need to reinvent the wheel here. A pragmatic approach would be to reuse standard implementations in OpenGL, WebGPU, CUDA or the platform of choice, to achieve optimal performance in whatever application one desires. </p>"},{"location":"conclusion/#sources","title":"Sources","text":"<p>[1] Pichler, T. A., Ferko, A., Ferko, M., K\u00e1n, P., &amp; Kaufmann, H. (2022). Precomputed fast rejection ray-triangle intersection.\u00a0Graphics and Visual Computing, 200047.</p> <p>[2] M\u00f6ller, T., &amp; Trumbore, B. (2005). Fast, minimum storage ray/triangle intersection. In\u00a0ACM SIGGRAPH 2005 Courses\u00a0(pp. 7-es).</p> <p>[3] \u00c1fra, A. T. (2012). Incoherent Ray Tracing without Acceleration Structures. In\u00a0Eurographics (Short Papers)\u00a0(pp. 97-100).</p>"},{"location":"example/","title":"Example usage","text":"<p>A typical use-case scenario can be as follows</p> <pre><code>\nimport numpy as np\n\nfrom sweetspot import ray, triangle, moller_trumbore_ray_triangle_intersection_numba\n\n# set up a triangle\nx1,x2,x3 = np.random.uniform(-1,1,(3,3))\nt = triangle(x1,x2,x3)\n\n# set up a ray\no,d = np.random.uniform(-1,1,(2,3))\nr = ray(o,d)\n\n# check if they intersect\nhit, a_star, p_star = moller_trumbore_ray_triangle_intersection_numba(r,t)\n\n# print results\nif hit:\n    print(\"ray intersects triangle at\", p_star)\n    print(\"in a distance\", p_star, \"from the origin.\")\nelse:\n    print(\"ray does not intersect triangle\")\n\n\n</code></pre>"},{"location":"installation/","title":"Installation and execution","text":"<p>The project has been implemented as a Python-module, dependent only on Numpy [1] and Numba [2]. </p> <p>You may install the project and its dependencies using the standard pip command from the projects root directoy:</p> <pre><code>pip install .\n</code></pre>"},{"location":"installation/#running-tests","title":"Running tests","text":""},{"location":"installation/#using-the-module","title":"Using the module","text":""},{"location":"installation/#import","title":"Import","text":"<p>The module is imported as</p> <pre><code>import sweetspot\n</code></pre>"},{"location":"installation/#triangles-and-rays","title":"Triangles and rays","text":"<p>You may thereafter create triangles:</p> <pre><code>t1 = sweetspot.triangle(x1,x2,x3)\n</code></pre> <p>...where <code>xn</code> are 3-component numpy arrays. A ray is instantiated as follows:</p> <pre><code>r1 = sweetspot.ray(o,d)\n</code></pre> <p>...where <code>o</code> and <code>d</code>\u00a0are 3-component numpy-arrays defining the rays origin and direction respectively (note that <code>d</code> will automatically be normalized).</p>"},{"location":"installation/#intersections","title":"Intersections","text":"<p>Finally, you may compute intersections using either the algebraic approach:</p> <pre><code>hit, a_star, p_star = sweetspot.algebraic_ray_triangle_intersection(r,t)\n</code></pre> <p>...the M\u00f6ller-Trumbore algorithm...</p> <pre><code>hit, a_star, p_star = sweetspot.moller_trumbore_ray_triangle_intersection(r,t)\n</code></pre> <p>...or a numba-optimized M\u00f6ller-Trumbore algorithm (which should be the goto choice at least within this module):</p> <pre><code>hit, a_star, p_star = sweetspot.moller_trumbore_ray_triangle_intersection_numba(r,t)\n</code></pre>"},{"location":"moller_trumbore/","title":"The M\u00f6ller-Trumbore algorithm","text":"<p>With a working solver for validation, we can move on to more advanced algorithms.  The M\u00f6ller-Trumbore algorithm was introduced in a 2005-paper titled \"Fast, minimum storage ray/triangle intersection\" [1], and is based on transforming the problem into barycentric coordinates. As previously discussed, the interserction point in barycentric coordinates is, when fully expanded</p> \\[\\mathbf{P}_{*} = \\mathbf{x}_1 u_1 + \\mathbf{x}_2 u_2 + \\mathbf{x}_3 u_3.\\] <p>From the relation in Eq.(7) we see that this can be rewritten</p> \\[\\mathbf{P}_{*} = \\mathbf{x}_1 (1-u_2 - u_3) + \\mathbf{x}_2 u_2 + \\mathbf{x}_3 u_3 ,\\] <p>which can be reorganized into</p> \\[\\mathbf{P}_{*} = \\mathbf{x}_1 + (\\mathbf{x}_2-\\mathbf{x}_1) u_2 + (\\mathbf{x}_3-\\mathbf{x}_1)u_3  .\\] <p>If we now insert the explicit expression for the ray, we find</p> \\[\\mathbf{O} + a_*\\mathbf{D} = \\mathbf{x}_1 + (\\mathbf{x}_2-\\mathbf{x}_1) u_2 + (\\mathbf{x}_3-\\mathbf{x}_1)u_3 ,\\] <p>which may be rearranged into</p> \\[\\mathbf{O} -\\mathbf{x}_1 = - a_*\\mathbf{D} + (\\mathbf{x}_2-\\mathbf{x}_1) u_2 + (\\mathbf{x}_3-\\mathbf{x}_1)u_3 ,\\] <p>where \\(u_1\\), \\(u_2\\) and \\(a_*\\) are unknown, forming a system of coupled equations:</p> \\[\\begin{align}   \u00a0 \u00a0  \\begin{bmatrix}   \u00a0 \u00a0        \\mathbf{-D}  , \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(\\mathbf{x}_{2}-\\mathbf{x}_{1}),\u00a0   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(\\mathbf{x}_{3}-\\mathbf{x}_{1})   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\end{bmatrix} \\begin{bmatrix}   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0   a_*  \\\\ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0u_{2}\u00a0\\\\   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0u_{3}\u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\end{bmatrix}=\\mathbf{O} -\\mathbf{x}_1 . \u00a0\\end{align}\\] <p>Since the elements in the first row-vector on the left are vectors, this is a \\(3 \\times 3\\) matrix. Realizing this, we may simplify once more to a matrix-vector product</p> \\[M\\mathbf{u}_* = \\tilde{\\mathbf{O}}, \\tag{8}\\] <p>which can be solved using any standard solver (preferably not by inversion) to find:</p> \\[\\mathbf{u}_* =M^{-1} \\tilde{\\mathbf{O}}.\\] <p>In their original paper [1], M\u00f6ller and Trumbore solve this system using Cramers rule [2]. We have followed the same procedure, i.e. by defining \\(\\mathbf{v}_{ij} = (\\mathbf{x}_{i}-\\mathbf{x}_{j})\\), whereby we finally compute</p> \\[\u00a0\\begin{align}     \u00a0 \u00a0  \\begin{bmatrix}   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0   a_*  \\\\ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0u_{2}\u00a0\\\\   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0u_{3}\u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\end{bmatrix}= \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\frac{1}{(\\mathbf{D} \\times \\mathbf{v}_{31}) \\cdot \\mathbf{v}_{21}} \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\begin{bmatrix}   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (\\tilde{\\mathbf{O}} \\times \\mathbf{v}_{21}) \\cdot \\mathbf{v}_{31} \\\\ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0(\\mathbf{D} \\times \\mathbf{v}_{31}) \\cdot \\tilde{\\mathbf{O}}\u00a0\\\\   \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (\\tilde{\\mathbf{O}} \\times \\mathbf{v}_{21})\\cdot{\\mathbf{D}} \u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\\end{bmatrix}. \\tag{9} \u00a0 \\end{align}\\] <p>As the note in the paper [1], it is possible to define intermediates in the above to speed up the calculation. </p>"},{"location":"moller_trumbore/#sources","title":"Sources","text":"<p>[1] M\u00f6ller, T., &amp; Trumbore, B. (2005). Fast, minimum storage ray/triangle intersection. In\u00a0ACM SIGGRAPH 2005 Courses\u00a0(pp. 7-es).</p> <p>[2] https://en.wikipedia.org/wiki/Cramer%27s_rule</p>"},{"location":"mt-reference/","title":"Sweetspot - The M\u00f6ller-Trumbore solver","text":""},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.moller_trumbore_ray_triangle_intersection","title":"<code>moller_trumbore_ray_triangle_intersection(Ray, Triangle)</code>","text":"<p>The M\u00f6ller-Trumbore algorithm for triangle-ray intersection evaluation</p> <p>Author: Audun Skau Hansen (audunsh4@gmail.com), 2022</p>"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.moller_trumbore_ray_triangle_intersection--keyword-arguments","title":"Keyword arguments:","text":"Method Description Ray An instance of the sweetspot.ray class Triangle An instance of the sweetspot.triangle class"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.moller_trumbore_ray_triangle_intersection--returns","title":"Returns","text":"<p>A tuple containing 'hit' (a boolean indicator of whether the ray intersected or not), a float value 'a_star' indicating the distance for which the ray intersected the triangle, and finally a vector 'p_star' indicating the cartesian vector of the intersection.</p> Source code in <code>sweetspot/moller_trumbore_solver.py</code> <pre><code>def moller_trumbore_ray_triangle_intersection(Ray: ray, Triangle: triangle)-&gt;(bool, float, np.array):\n    \"\"\"\n    The M\u00f6ller-Trumbore algorithm for triangle-ray intersection evaluation\n\n    Author: Audun Skau Hansen (audunsh4@gmail.com), 2022\n\n    ## Keyword arguments:\n\n    | Method      | Description |\n    | ----------- | ----------- |\n    | Ray      |  An instance of the sweetspot.ray class    |\n    | Triangle   | An instance of the sweetspot.triangle class      |\n\n    ## Returns  \n\n    A tuple containing 'hit' (a boolean indicator of whether the ray intersected or not),\n    a float value 'a_star' indicating the distance for which the ray intersected the triangle,\n    and finally a vector 'p_star' indicating the cartesian vector of the intersection.\n\n    \"\"\"\n    hit = False\n    a_star = 0\n    p_star = np.zeros(3)\n\n    # the required variables\n    v21 = Triangle.compute_edge_vector(1,0)\n    v31 = Triangle.compute_edge_vector(2,0)\n    D = Ray.direction\n    O = Ray.origin\n\n    x1,x2,x3 = Triangle.X\n\n\n    # intermediates (to avoid recomputing stuff)\n    D_x_v31 = np.cross(D, v31)\n\n    # Computing the denominator in Eq. 9\n    denom = D_x_v31.dot(v21) #**-1\n\n    if abs(denom)&lt;1e-14:\n        return (hit, a_star, p_star)\n\n    Otilde = O - x1\n\n    det = 1.0/denom\n\n    u2 = det*D_x_v31.dot(Otilde)\n\n    if u2&lt;0:\n        # point outside\n        return (hit, a_star, p_star)\n\n    O_x_v21 = np.cross(Otilde, v21)\n\n    u3 = det*O_x_v21.dot(D)\n\n    if u3&lt;0 or u2+u3&gt;1.0:\n        # point outside\n        return (hit, a_star, p_star)\n\n\n    # Computing the full Eq. 9 \n    a_star = det * O_x_v21.dot(v31)\n\n    #u1 = 1 - u2 - u3\n\n    # Collect and return reults\n    if a_star&lt;0:\n        # triangle behind\n        return (hit, a_star, p_star)\n\n    hit = True\n\n    p_star = O + a_star*D\n\n    return (hit, a_star, p_star)\n</code></pre>"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.moller_trumbore_ray_triangle_intersection_numba","title":"<code>moller_trumbore_ray_triangle_intersection_numba(Ray, Triangle)</code>","text":"<p>A wrapper for the numba-optimized M\u00f6ller-Trumbore algorithm for triangle-ray intersection evaluation</p> <p>Author: Audun Skau Hansen (audunsh4@gmail.com), 2022</p>"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.moller_trumbore_ray_triangle_intersection_numba--keyword-arguments","title":"Keyword arguments:","text":"Method Description Ray An instance of the sweetspot.ray class Triangle An instance of the sweetspot.triangle class"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.moller_trumbore_ray_triangle_intersection_numba--returns","title":"Returns","text":"<p>A tuple containing 'hit' (a boolean indicator of whether the ray intersected or not), a float value 'a_star' indicating the distance for which the ray intersected the triangle, and finally a vector 'p_star' indicating the cartesian vector of the intersection.</p> Source code in <code>sweetspot/moller_trumbore_solver.py</code> <pre><code>def moller_trumbore_ray_triangle_intersection_numba(Ray: ray, Triangle: triangle)-&gt;(bool, float, np.array):\n    \"\"\"\n    A wrapper for the numba-optimized M\u00f6ller-Trumbore algorithm for triangle-ray intersection evaluation\n\n    Author: Audun Skau Hansen (audunsh4@gmail.com), 2022\n\n    ## Keyword arguments:\n\n    | Method      | Description |\n    | ----------- | ----------- |\n    | Ray      |  An instance of the sweetspot.ray class    |\n    | Triangle   | An instance of the sweetspot.triangle class      |\n\n    ## Returns  \n\n    A tuple containing 'hit' (a boolean indicator of whether the ray intersected or not),\n    a float value 'a_star' indicating the distance for which the ray intersected the triangle,\n    and finally a vector 'p_star' indicating the cartesian vector of the intersection.\n    \"\"\"\n    x1,x2,x3 = Triangle.X\n    D = Ray.direction\n    O = Ray.origin\n    a_star = mt_rt_intersect_numba(x1,x2,x3,D,O)\n    if a_star is None:\n        return False , 0, O\n    else:\n        return True, a_star, Ray.get_point_at(a_star)\n</code></pre>"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.mt_rt_intersect_numba","title":"<code>mt_rt_intersect_numba(x1, x2, x3, D, O)</code>","text":"<p>A numba-optimized M\u00f6ller-Trumbore algorithm for triangle-ray intersection evaluation</p> <p>Author: Audun Skau Hansen (audunsh4@gmail.com), 2022</p>"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.mt_rt_intersect_numba--keyword-arguments","title":"Keyword arguments:","text":"Argumentts Description x1,x2,x3 3-component numpy-arrays containing the triangle vertices D, O 3-component numpy arrays contatining the direction and origin of the ray"},{"location":"mt-reference/#sweetspot.moller_trumbore_solver.mt_rt_intersect_numba--returns","title":"Returns","text":"<p>The value 'a_star' if intersection occurs, None else.</p> Source code in <code>sweetspot/moller_trumbore_solver.py</code> <pre><code>@nb.jit(nopython=True)\ndef mt_rt_intersect_numba(x1,x2,x3,D,O):\n    \"\"\"\n    A numba-optimized M\u00f6ller-Trumbore algorithm for triangle-ray intersection evaluation\n\n    Author: Audun Skau Hansen (audunsh4@gmail.com), 2022\n\n    ## Keyword arguments:\n\n    | Argumentts      | Description |\n    | ----------- | ----------- |\n    | x1,x2,x3      | 3-component numpy-arrays containing the triangle vertices   |\n    | D, O   | 3-component numpy arrays contatining the direction and origin of the ray     |\n\n    ## Returns\n\n    The value 'a_star' if intersection occurs, None else.\n    \"\"\"\n\n\n    v21 = x2-x1\n    v31 = x3-x1\n    # intermediates (to avoid recomputing stuff)\n    D_x_v31 = np.cross(D, v31)\n\n    # Computing the denominator in Eq. 9\n    denom = D_x_v31.dot(v21) #**-1\n\n    if abs(denom)&lt;1e-14:\n        return None\n\n    Otilde = O - x1\n\n    det = 1.0/denom\n\n    u2 = det*D_x_v31.dot(Otilde)\n\n    if u2&lt;0:\n        # point outside\n        return None\n\n    O_x_v21 = np.cross(Otilde, v21)\n\n    u3 = det*O_x_v21.dot(D)\n\n    if u3&lt;0 or u2+u3&gt;1.0:\n        # point outside\n        return None\n\n\n    # Computing the full Eq. 9 \n    a_star = det * O_x_v21.dot(v31)\n\n\n    # Collect and return reults\n    if a_star&lt;0:\n        # triangle behind\n        return None\n\n\n    return a_star\n</code></pre>"},{"location":"validation/","title":"Evaluation","text":""},{"location":"validation/#validation","title":"Validation","text":"<p>Although the algebraic approach may seem more transparent (and thus less prone to implementational errors) from as purely conceptual perspective, the resulting Python-script has about the same readability as the M\u00f6ller-Trumbore script. Thus, the validation has been performed as follows:</p> <ol> <li>The barycentric coordinate transform was tested against a trusted algorithm in the Trimesh [1] module (A well maintained and 2.2K starred github repo). </li> <li>A few tailored cases for intersecting and non-intersecting rays and triangles was tested with the algebraic solver.</li> <li>A randomly generated set containing both intersecting and non-intersecting rays and triangles (500 cases) was visually inspected and compared to the results from the algebraic solver.  </li> <li>The M\u00f6ller-Trumbore algorithm was tested against the algebraic solver for 100000 randomly generated cases.</li> <li>Finally, a Numba[2]-optimized M\u00f6ller-Trumbore algorithm was tested against the algebraic solver.</li> </ol> <p>The algorithms reproduce eachother exactly, and agrees well with both the designed and visually inspected results. We may thus have confidence in these implementations.</p>"},{"location":"validation/#notes-on-performance","title":"Notes on performance","text":"<p>An internal benchmark comparison was made between the algebraic solver, the pure Python M\u00f6ller-Trembore algorithm, and the numba-accelerated variant. The time per iteration (measuring 1e6 randomly generated pairs with a hit-rate of about 5%) in seconds was respectively 88.3e-6, 51.1e-6 and 2.2e-6 on my laptop CPU (Macbook Pro, 2018) - quite far above the state-of-the art 0.05e-6 seconds performance reported in the literature [3]. This can be due to many factors, probably overhead in Python, difference in the hardware, and probably most notably that these algorithms in general should be devised to work on batches of data (not single instances). </p>"},{"location":"validation/#sources","title":"Sources","text":"<p>[1] https://trimsh.org/index.html</p> <p>[2] https://numba.pydata.org/</p> <p>[3] Pichler, T. A., Ferko, A., Ferko, M., K\u00e1n, P., &amp; Kaufmann, H. (2022). Precomputed fast rejection ray-triangle intersection.\u00a0Graphics and Visual Computing, 200047.</p>"}]}